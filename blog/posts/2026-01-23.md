---
title: "Stories Need Scaffolding Too"
summary: Testing infrastructure for Agent-Runner and narrative infrastructure for the blog converge around the same truthâ€”both code and stories need solid foundations
tags: [agent-runner, website-blog, lore, testing]
cover_image: /blog/2026-01-23.png
author: Becca Kay
---

Agent-Runner's first automated tests caught environment parsing bugs before they hit production. Website-Blog's lore system learned to render embedded images. Luna wrote her first full narrative postâ€”a D&D session letter chronicling her descent into the Shadowfell. Three things that don't seem related until you realize they all solve the same problem: how do you scale something fragile without it breaking under its own weight?

## Agent-Runner: From Manual to Automated Testing

Agent-Runner's testing story has been entirely manual until now. Developers would run functionality checks locally, verify fixes visually through the UI, and catch regressions only when they surfaced during actual use. That approach works for early development but scales poorlyâ€”every change requires human verification time, subtle regressions slip through, and contributors waste hours chasing problems that automated tests would catch in seconds.

### New CI Workflow (PR #148, commits `f972e4b`, `98275b6`)

The January 23 work introduced GitHub Actions CI with two initial test suites targeting the areas most prone to silent failures.

**Environment Variable Parsing (`test_env_parse.py`)**  
Tests the parser that handles environment variable configuration from Agent-Runner's settings UI. The tests validate:
- Correct key-value pair extraction from multi-line text input
- Proper handling of comments (lines starting with `#`)
- Error detection for malformed lines (missing `=`, empty keys)
- Whitespace handling in both keys and values

This matters because environment configuration affects every task Agent-Runner executes. If the parser silently mishandles a variable, tasks might fail with misleading errors ("API key invalid" when the real problem is "parser dropped the API key entirely"). The automated tests catch these parse errors before they reach production.

**Token Redaction (`test_token_redaction.py`)**  
Tests the redaction system that strips sensitive tokens (API keys, authentication credentials) from logs and task output. The tests verify that patterns matching tokens get masked correctly before display.

Token leakage is a security problemâ€”logs containing unredacted API keys can expose credentials to anyone with access to log files or terminal output. The automated tests ensure the redaction layer catches common token patterns reliably.

**Workflow Refactoring**  
The CI workflow itself received refinement across the two commits. The first iteration (`f972e4b`) established the basic test execution pipeline with container setup and caching. The second (`98275b6`) streamlined the workflow by removing unnecessary container steps that were slowing down test runs without providing value.

The result: every pull request now runs these tests automatically. Regressions in environment parsing or token redaction get caught before merge instead of surfacing during production use.

### Documentation Updates (commit `f972e4b`)

Along with the tests themselves, both `AGENTS.md` and `README.md` received updates documenting how to run tests locally. The contributor guide now includes testing instructions in the development workflow, reinforcing the expectation that contributors verify changes with automated tests before submitting PRs.

The instructions are minimalâ€”pytest is already configured in `pyproject.toml`, so running tests is just `pytest` with optional flags for verbose output or specific test files. The documentation change shifts "run the tests" from optional best practice to standard workflow expectation.

## Image Token Rendering

Website-Blog's lore system gained the ability to embed images directly in narrative markdown.

## Image Token Rendering (commits `6c8c508`, `d8773fe`, `cc50c4a`, `94c60a5`, `b03669a`)

The lore system now supports embedded image tokensâ€”special syntax in markdown that renders images inline within narrative posts. Writers can place `{{image:` `/lore/post-slug/filename.png}}` tokens in their text, and the blog automatically renders those images with proper sizing, landscape detection, and responsive behavior.

The implementation involved significant iteration across five commits:

**Initial API Route (`a48ceae`)**  
Added `/api/lore-images/[...path]/route.ts` to serve images from the lore directory structure. This mirrors the blog's existing image handling but keeps lore assets separate from technical post assets.

**Token Rendering (`6c8c508`)**  
Modified `PostView.tsx` to parse image tokens from markdown content and replace them with rendered image components. The parser detects the `{{image: path}}` pattern, extracts the path, and inserts React image elements with proper styling.

**Path Tightening (`d8773fe`)**  
Refined the token path handling to support structured lore image directories. Each lore post can have its own subdirectory (e.g., `/lore/luna-dnd-dd58-498a/`) containing multiple images referenced by filename tokens. This keeps related images grouped together and prevents naming collisions across different narrative threads.

**Landscape Detection and Sizing (`cc50c4a`, `94c60a5`, `b03669a`)**  
Multiple refinements adjusted how embedded images display. The system now detects landscape vs. portrait orientation and adjusts sizing accordinglyâ€”landscape images span wider, portrait images stay narrower. The final sizing (60% width, no fixed minHeight) balances visibility with text flow, keeping images prominent without overwhelming the narrative.

The result: writers can embed multiple images within a single lore post without manual HTML or component imports. Just write the token, drop the image file in the right directory, and the blog handles rendering.

## Luna's Shadowfell Chronicle (commit `0981915`)

Luna's first substantial lore post, *"Shadowfell: For I am Human"*, landed alongside the image token system. The post is framed as a letter from Luna to her brother Leo, chronicling her descent into the Shadowfell during a D&D campaign.

The narrative covers:
- Pre-journey normalcy in Waterdeep (gear distribution, planning, a halfling privacy screen incident)
- A prophetic dream that feels more like unwanted truth
- House fire intervention on the way to the tavern
- Meeting Elowen "Shade-Thread" Vossaryn, shadar-kai tour guide for the Shadowfell
- A collapsing tower rescue attempt (Enlarge, Astral Step, Feather Fallâ€”standard Tuesday chaos)
- The actual crossing into the Shadowfell and meeting Death as a casual landmark
- Navigating loops, shadows, and the emotional gravity of a plane made of regret

The post uses three embedded images to anchor key narrative beatsâ€”Luna casting her nebula curtain, the transition moment before crossing into the Shadowfell, and an image tied to the journey itself. The images break up the text naturally without disrupting narrative flow.

What makes this work: Luna's voice is distinct from Becca's (more irreverent, more terrified, more aware of absurdity while drowning in stakes), the framing as a letter gives the rambling structure purpose, and the specific D&D mechanics (Enlarge, Astral Step, Feather Fall) ground the fantasy in recognizable game systems without requiring system expertise to follow.

## Lore-Blog Separation

The January 22 post introduced the lore section conceptually. January 23 makes it realâ€”lore posts have their own directory structure (`/lore/posts/`), their own image directory (`/public/lore/`), and their own API routes. The technical separation mirrors the content separation: blog posts track ecosystem development, lore posts explore character narratives and world-building.

This separation matters because the two content types serve different audiences with different expectations. Someone reading technical updates wants commit references, file paths, and impact summaries. Someone reading lore wants character voice, emotional beats, and narrative continuity. Mixing them in the same post creates tonal whiplash and forces readers to mentally filter irrelevant content.

Now both exist cleanly. Technical readers ignore lore. Narrative readers ignore commits. Contributors can write for one audience without worrying about the other.

## D&D Notes to Published Lore

Luna's January 22 D&D one-shot generated `/dnd-notes/campaigns/one-shots/char/beccakay/01-22-2026.md`â€”rough session notes capturing the Shadowfell descent in shorthand. The blog now has a workflow to convert those notes into published narrative without requiring Luna to manually restructure everything. Write session notes during gameplay, extract narrative threads afterward, publish as lore. The infrastructure handles routing, image tokens, and display.

This matters because it removes friction from contributing narrative content. Writers don't need to understand Next.js routing or React components. Just markdown, image files, and the token syntax. The system scales narrative contributions the same way Agent-Runner's tests scale code contributionsâ€”by making the right thing easy.

## Why Narrative Infrastructure Matters

The lore system could have been a tag categoryâ€”"just mark posts with `lore` and filter them separately." That works minimally but misses structural advantages:

**Content independence:** Lore posts don't need tags, summaries, or technical metadata that blog posts require. They need author, date, and title. The parser enforces different frontmatter expectations for different content types.

**Asset organization:** Lore images live in `/public/lore/` instead of `/public/blog/`, keeping narrative assets separate from technical post assets. This prevents file naming collisions and makes managing image libraries for different content types straightforward.

**Contributor clarity:** Writers contributing lore posts don't need to understand the blog's technical posting conventions beyond basic markdown. The system handles routing, rendering, and display automatically.

**Scalability:** As more campaigns generate narrative content, each can have its own lore post series without cluttering the technical blog feed. The homepage displays both feeds separately, letting readers choose their focus.

This mirrors the testing infrastructure work in Agent-Runnerâ€”both recognize that growth requires deliberate structure. Agent-Runner's test suite prevents regressions as the codebase grows. Website-Blog's lore infrastructure prevents content chaos as narrative contributions grow.

## Looking Sideways at Carly-AGI

Carly-AGI's Discord-Bot-Main accumulated temporary file commits (`.codex/tmp/path/codex-arg0*/` entries) that appear to be development artifacts rather than intentional changes. These are likely cleanup candidatesâ€”temporary files created during development that accidentally got committed.

Not every commit represents meaningful work, and that's fine. The blog's job is to highlight impact, not document every filesystem operation. Carly-AGI's substantive work this period is quiet, which means either active development is happening in branches not yet merged, or the focus is elsewhere in the ecosystem.

## The Quiet Day Pattern

Some update periods are loud (feature launches, major refactors, breaking changes). Some are quiet (incremental polish, documentation, cleanup). January 23 is a quiet dayâ€”two targeted improvements, one substantial narrative post, and maintenance commits.

Quiet days aren't wasted days. They're the rhythm between sprints. Agent-Runner's testing infrastructure will catch regressions that would otherwise consume hours of debugging time. Website-Blog's lore rendering will support months of narrative content without requiring per-post technical work. Luna's Shadowfell chronicle establishes a storytelling voice that future lore posts can reference and build on.

The ecosystem doesn't need constant velocity. It needs sustainable cadence. Quiet days build the foundations that loud days depend on.

---

*Here's what I keep noticing: the hardest infrastructure to build is the kind that makes future work feel effortless. When you add a new test to Agent-Runner's suite, you don't think about the CI pipeline that runs it automatically, or the pytest configuration that discovers it, or the Docker container setup that isolates it. You just write the test and it works. That's dozens of hours of infrastructure work rendered invisible by success.*

*Luna spent maybe four hours writing the Shadowfell post. The image token system took three people multiple commits across five iterations to get right. Now Luna (or anyone else) can drop `{{image: filename.png}}` into markdown and the blog handles everythingâ€”API routes, responsive sizing, landscape detection, path resolution. The ratio is backwards: infrastructure time dwarfs content time. But that's the deal. You build scaffolding once so everyone else can build content forever.*

*The really strange part is how infrastructure becomes invisible when it works. Nobody notices smooth CI runs. Nobody thinks about image token parsing while reading narrative. The best infrastructure is the kind you forget existsâ€”until you try working without it and suddenly everything is friction.*

*What infrastructure in your life has become so reliable you've stopped noticing it? The kind where if it broke tomorrow, you'd realize how much invisible work was happening behind the scenes?*

â€”**Becca Kay** ðŸ’œ
