---
title: Securing Your Web Application
tags: [security, web-development, best-practices]
---

# Securing Your Web Application

Web security is not optional. Here are essential practices to protect your application and users.

## Common Vulnerabilities

### 1. SQL Injection

**Vulnerable Code:**
```javascript
const query = `SELECT * FROM users WHERE email = '${userInput}'`;
```

**Secure Code:**
```javascript
const query = 'SELECT * FROM users WHERE email = ?';
db.execute(query, [userInput]);
```

### 2. Cross-Site Scripting (XSS)

**Problem:**
```html
<div>{userInput}</div>  <!-- Dangerous! -->
```

**Solution:**
```javascript
// Sanitize input
import DOMPurify from 'dompurify';
const clean = DOMPurify.sanitize(userInput);
```

### 3. Cross-Site Request Forgery (CSRF)

Use CSRF tokens:
```javascript
// Generate token
const csrfToken = crypto.randomBytes(32).toString('hex');

// Include in forms
<input type="hidden" name="_csrf" value="${csrfToken}">

// Verify on server
if (req.body._csrf !== req.session.csrfToken) {
  return res.status(403).send('Invalid CSRF token');
}
```

## Authentication Best Practices

### Password Security

```javascript
// Never store plain text passwords!
import bcrypt from 'bcrypt';

// Hash password
const saltRounds = 10;
const hashedPassword = await bcrypt.hash(password, saltRounds);

// Verify password
const isValid = await bcrypt.compare(password, hashedPassword);
```

### JWT Tokens

```javascript
import jwt from 'jsonwebtoken';

// Create token
const token = jwt.sign(
  { userId: user.id },
  process.env.JWT_SECRET,
  { expiresIn: '1h' }
);

// Verify token
const decoded = jwt.verify(token, process.env.JWT_SECRET);
```

## HTTPS Everywhere

```nginx
# Redirect HTTP to HTTPS
server {
    listen 80;
    server_name example.com;
    return 301 https://$server_name$request_uri;
}

# HTTPS configuration
server {
    listen 443 ssl http2;
    server_name example.com;
    
    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
}
```

## Security Headers

```javascript
// Set security headers
app.use((req, res, next) => {
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Strict-Transport-Security', 
    'max-age=31536000; includeSubDomains');
  res.setHeader('Content-Security-Policy', 
    "default-src 'self'");
  next();
});
```

## Input Validation

```javascript
// Validate all input
import { z } from 'zod';

const userSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8),
  age: z.number().min(18).max(120)
});

try {
  const validated = userSchema.parse(req.body);
  // Process validated data
} catch (error) {
  return res.status(400).json({ error: error.errors });
}
```

## Rate Limiting

```javascript
import rateLimit from 'express-rate-limit';

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});

app.use('/api/', limiter);
```

## Environment Variables

```bash
# Never commit secrets to version control
# Use environment variables
DATABASE_URL=postgresql://user:pass@localhost/db
JWT_SECRET=your-secret-key-here
API_KEY=your-api-key
```

```javascript
// Load from .env file
require('dotenv').config();

const dbUrl = process.env.DATABASE_URL;
```

## Security Checklist

- [ ] Use HTTPS everywhere
- [ ] Implement proper authentication
- [ ] Validate and sanitize all input
- [ ] Use parameterized queries
- [ ] Set security headers
- [ ] Implement rate limiting
- [ ] Keep dependencies updated
- [ ] Use CSP (Content Security Policy)
- [ ] Enable CORS properly
- [ ] Log security events
- [ ] Regular security audits
- [ ] Implement proper error handling

## Dependency Security

```bash
# Check for vulnerabilities
npm audit

# Fix vulnerabilities
npm audit fix

# Use dependabot or renovate for automated updates
```

Security is an ongoing process, not a one-time task. Stay vigilant!
