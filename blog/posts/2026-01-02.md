---
title: Introduction to GraphQL
summary: Learn GraphQL basics and why it's revolutionizing API development
tags: [graphql, api, backend]
---

# Introduction to GraphQL

GraphQL is a query language for APIs that gives clients the power to request exactly what they need. Let's explore why it's gaining popularity.

## What is GraphQL?

GraphQL is a specification for querying and manipulating data. Unlike REST, where you have multiple endpoints, GraphQL exposes a single endpoint that responds to queries.

## Key Concepts

### Schema

Define your data structure:

```graphql
type User {
  id: ID!
  name: String!
  email: String!
  posts: [Post!]!
}

type Post {
  id: ID!
  title: String!
  content: String!
  author: User!
  comments: [Comment!]!
}

type Comment {
  id: ID!
  text: String!
  author: User!
}
```

### Queries

Request exactly what you need:

```graphql
query GetUser {
  user(id: "123") {
    name
    email
    posts {
      title
      comments {
        text
        author {
          name
        }
      }
    }
  }
}
```

### Mutations

Modify data:

```graphql
mutation CreatePost {
  createPost(input: {
    title: "New Post"
    content: "Post content"
    authorId: "123"
  }) {
    id
    title
    author {
      name
    }
  }
}
```

## Setting Up GraphQL Server

Using Apollo Server:

```javascript
import { ApolloServer } from '@apollo/server';
import { startStandaloneServer } from '@apollo/server/standalone';

// Type definitions
const typeDefs = `#graphql
  type User {
    id: ID!
    name: String!
    email: String!
  }

  type Query {
    users: [User!]!
    user(id: ID!): User
  }

  type Mutation {
    createUser(name: String!, email: String!): User!
  }
`;

// Resolvers
const resolvers = {
  Query: {
    users: () => {
      return getAllUsers();
    },
    user: (parent, args) => {
      return getUserById(args.id);
    }
  },
  Mutation: {
    createUser: (parent, args) => {
      return createUser(args.name, args.email);
    }
  }
};

// Create server
const server = new ApolloServer({
  typeDefs,
  resolvers,
});

const { url } = await startStandaloneServer(server, {
  port: 4000,
});

console.log(`Server ready at ${url}`);
```

## Client-Side with Apollo Client

```javascript
import { ApolloClient, InMemoryCache, gql, useQuery } from '@apollo/client';

const client = new ApolloClient({
  uri: 'http://localhost:4000/graphql',
  cache: new InMemoryCache(),
});

// React component
function UserProfile({ userId }) {
  const GET_USER = gql`
    query GetUser($id: ID!) {
      user(id: $id) {
        name
        email
        posts {
          title
        }
      }
    }
  `;

  const { loading, error, data } = useQuery(GET_USER, {
    variables: { id: userId },
  });

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      <h1>{data.user.name}</h1>
      <p>{data.user.email}</p>
      <h2>Posts</h2>
      <ul>
        {data.user.posts.map(post => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

## GraphQL vs REST

### GraphQL Advantages
- No over-fetching or under-fetching
- Single request for multiple resources
- Strong typing
- Introspection
- Real-time with subscriptions

### When to Use REST
- Simple, resource-based APIs
- Caching is critical
- File uploads/downloads
- Team is unfamiliar with GraphQL

## Subscriptions

Real-time updates:

```graphql
type Subscription {
  postAdded: Post!
}

subscription {
  postAdded {
    id
    title
    author {
      name
    }
  }
}
```

Server implementation:

```javascript
import { PubSub } from 'graphql-subscriptions';

const pubsub = new PubSub();

const resolvers = {
  Subscription: {
    postAdded: {
      subscribe: () => pubsub.asyncIterator(['POST_ADDED'])
    }
  },
  Mutation: {
    createPost: (parent, args) => {
      const post = createPost(args);
      pubsub.publish('POST_ADDED', { postAdded: post });
      return post;
    }
  }
};
```

## Best Practices

1. **Design schema carefully**: It's your API contract
2. **Use DataLoader**: Avoid N+1 query problems
3. **Implement authentication**: Protect sensitive data
4. **Add pagination**: For large lists
5. **Version carefully**: Schema changes affect all clients
6. **Monitor performance**: Track resolver execution times

GraphQL gives you powerful, flexible APIs. Start exploring today!
