---
title: Database Design Principles
summary: Learn the fundamentals of designing efficient databases
tags: [database, design, sql]
---

# Database Design Principles

Good database design is the foundation of efficient applications. Let's explore key principles for designing robust databases.

## Normalization

Organize data to reduce redundancy and improve integrity.

### First Normal Form (1NF)
- Atomic values (no arrays in cells)
- No repeating groups
- Each column has a unique name

### Second Normal Form (2NF)
- Meets 1NF requirements
- No partial dependencies
- All non-key attributes depend on the entire primary key

### Third Normal Form (3NF)
- Meets 2NF requirements
- No transitive dependencies
- Non-key attributes depend only on the primary key

## Example: E-commerce Database

```sql
-- Users table
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  name VARCHAR(100) NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Products table
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  price DECIMAL(10, 2) NOT NULL,
  stock_quantity INTEGER DEFAULT 0,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Orders table
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  user_id INTEGER REFERENCES users(id),
  total_amount DECIMAL(10, 2) NOT NULL,
  status VARCHAR(50) DEFAULT 'pending',
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Order items (many-to-many relationship)
CREATE TABLE order_items (
  id SERIAL PRIMARY KEY,
  order_id INTEGER REFERENCES orders(id),
  product_id INTEGER REFERENCES products(id),
  quantity INTEGER NOT NULL,
  price DECIMAL(10, 2) NOT NULL
);
```

## Indexing Strategies

Indexes speed up queries but slow down writes.

```sql
-- Index on frequently queried columns
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_orders_user_id ON orders(user_id);
CREATE INDEX idx_products_name ON products(name);

-- Composite index for common query patterns
CREATE INDEX idx_orders_user_status 
  ON orders(user_id, status);
```

## Relationships

### One-to-Many
User has many orders

### Many-to-Many
Products and categories (requires junction table)

### One-to-One
User has one profile

## Best Practices

1. **Use appropriate data types**: Don't use VARCHAR(255) for everything
2. **Add constraints**: Ensure data integrity at database level
3. **Use foreign keys**: Maintain referential integrity
4. **Choose primary keys wisely**: Auto-incrementing integers are usually best
5. **Avoid NULL when possible**: Use NOT NULL with DEFAULT values

## Query Optimization

```sql
-- Bad: Full table scan
SELECT * FROM users WHERE LOWER(email) = 'user@example.com';

-- Good: Uses index
SELECT * FROM users WHERE email = 'user@example.com';

-- Use EXPLAIN to analyze queries
EXPLAIN ANALYZE
SELECT u.name, COUNT(o.id) as order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.id, u.name;
```

## Denormalization (When Needed)

Sometimes breaking normalization rules improves performance:
- Read-heavy applications
- Aggregated data
- Reporting tables

```sql
-- Denormalized for faster reads
CREATE TABLE order_summary (
  user_id INTEGER,
  total_orders INTEGER,
  total_spent DECIMAL(10, 2),
  last_order_date TIMESTAMP,
  PRIMARY KEY (user_id)
);
```

## Backup and Recovery

Always have a backup strategy:
- Regular automated backups
- Test restore procedures
- Keep backups in multiple locations
- Document recovery procedures

Great database design makes everything else easier. Plan well from the start!
